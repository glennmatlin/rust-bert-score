//! Benchmarks for rust-bert-score components.

#![feature(test)]
extern crate test;

use rust_bert_score::{
    similarity::{compute_bertscore, create_scoring_mask},
    idf::IdfDict,
    baseline::{BaselineScores, BaselineManager},
};
use std::collections::HashSet;
use tch::{Device, Tensor};
use test::Bencher;

#[bench]
fn bench_normalize_embeddings(b: &mut Bencher) {
    let embeddings = Tensor::randn(&[100, 768], (tch::Kind::Float, Device::Cpu));
    
    b.iter(|| {
        let normalized = embeddings.norm_scalaropt_dim(2.0, &[1], true);
        let _ = &embeddings / &normalized.clamp_min(1e-12);
    });
}

#[bench]
fn bench_cosine_similarity_small(b: &mut Bencher) {
    let cand_emb = Tensor::randn(&[10, 768], (tch::Kind::Float, Device::Cpu));
    let ref_emb = Tensor::randn(&[12, 768], (tch::Kind::Float, Device::Cpu));
    let cand_mask = Tensor::ones(&[10], (tch::Kind::Float, Device::Cpu));
    let ref_mask = Tensor::ones(&[12], (tch::Kind::Float, Device::Cpu));
    
    b.iter(|| {
        let _ = compute_bertscore(&cand_emb, &ref_emb, &cand_mask, &ref_mask, None);
    });
}

#[bench]
fn bench_cosine_similarity_medium(b: &mut Bencher) {
    let cand_emb = Tensor::randn(&[50, 768], (tch::Kind::Float, Device::Cpu));
    let ref_emb = Tensor::randn(&[50, 768], (tch::Kind::Float, Device::Cpu));
    let cand_mask = Tensor::ones(&[50], (tch::Kind::Float, Device::Cpu));
    let ref_mask = Tensor::ones(&[50], (tch::Kind::Float, Device::Cpu));
    
    b.iter(|| {
        let _ = compute_bertscore(&cand_emb, &ref_emb, &cand_mask, &ref_mask, None);
    });
}

#[bench]
fn bench_cosine_similarity_large(b: &mut Bencher) {
    let cand_emb = Tensor::randn(&[100, 768], (tch::Kind::Float, Device::Cpu));
    let ref_emb = Tensor::randn(&[100, 768], (tch::Kind::Float, Device::Cpu));
    let cand_mask = Tensor::ones(&[100], (tch::Kind::Float, Device::Cpu));
    let ref_mask = Tensor::ones(&[100], (tch::Kind::Float, Device::Cpu));
    
    b.iter(|| {
        let _ = compute_bertscore(&cand_emb, &ref_emb, &cand_mask, &ref_mask, None);
    });
}

#[bench]
fn bench_idf_computation(b: &mut Bencher) {
    let references: Vec<Vec<i64>> = (0..1000)
        .map(|i| {
            (0..20).map(|j| ((i * 7 + j * 13) % 100) as i64).collect()
        })
        .collect();
    
    let special_tokens = HashSet::from([0, 1, 2]);
    
    b.iter(|| {
        let _ = IdfDict::from_references(&references, &special_tokens);
    });
}

#[bench]
fn bench_idf_weight_conversion(b: &mut Bencher) {
    let references = vec![
        vec![1, 2, 3, 4, 5],
        vec![2, 3, 6, 7, 8],
        vec![1, 4, 9, 10, 11],
    ];
    let special_tokens = HashSet::from([0]);
    let idf_dict = IdfDict::from_references(&references, &special_tokens).unwrap();
    
    let token_ids: Vec<i64> = (0..100).collect();
    
    b.iter(|| {
        let _ = idf_dict.to_weight_tensor(&token_ids, &special_tokens, Device::Cpu);
    });
}

#[bench]
fn bench_baseline_rescaling(b: &mut Bencher) {
    let baseline = BaselineScores::new(0.85, 0.85, 0.85);
    
    b.iter(|| {
        let _ = baseline.rescale(0.92, 0.90, 0.91);
    });
}

#[bench]
fn bench_baseline_manager_lookup(b: &mut Bencher) {
    let manager = BaselineManager::with_defaults();
    
    b.iter(|| {
        let _ = manager.get_baseline("roberta-large", "en");
    });
}

#[bench]
fn bench_create_scoring_mask(b: &mut Bencher) {
    let token_ids: Vec<i64> = (0..100).collect();
    let special_token_ids = vec![0, 1, 2];
    
    b.iter(|| {
        let _ = create_scoring_mask(&token_ids, &special_token_ids, 100);
    });
}

#[bench]
fn bench_matrix_multiplication(b: &mut Bencher) {
    let a = Tensor::randn(&[64, 768], (tch::Kind::Float, Device::Cpu));
    let b = Tensor::randn(&[768, 64], (tch::Kind::Float, Device::Cpu));
    
    b.iter(|| {
        let _ = a.matmul(&b);
    });
}